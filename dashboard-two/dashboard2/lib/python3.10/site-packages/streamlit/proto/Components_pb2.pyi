"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*!
Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2026)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

from collections import abc as _abc
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf.internal import containers as _containers
import builtins as _builtins
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

DESCRIPTOR: _descriptor.FileDescriptor

@_typing.final
class ComponentInstance(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    ID_FIELD_NUMBER: _builtins.int
    JSON_ARGS_FIELD_NUMBER: _builtins.int
    SPECIAL_ARGS_FIELD_NUMBER: _builtins.int
    COMPONENT_NAME_FIELD_NUMBER: _builtins.int
    URL_FIELD_NUMBER: _builtins.int
    FORM_ID_FIELD_NUMBER: _builtins.int
    TAB_INDEX_FIELD_NUMBER: _builtins.int
    id: _builtins.str
    """The instance's "widget ID", used to uniquely identify it."""
    json_args: _builtins.str
    """Argument dictionary, for JSON-serializable args."""
    component_name: _builtins.str
    """The component type's unique name."""
    url: _builtins.str
    """Optional URL to load the component from. By default this is not set,
    but while testing, a user can e.g. point this to a local node server
    that they're developing their component in.
    """
    form_id: _builtins.str
    tab_index: _builtins.int
    @_builtins.property
    def special_args(self) -> _containers.RepeatedCompositeFieldContainer[Global___SpecialArg]:
        """Additional, non-JSON args. These require special processing
        on the other end.
        """

    def __init__(
        self,
        *,
        id: _builtins.str = ...,
        json_args: _builtins.str = ...,
        special_args: _abc.Iterable[Global___SpecialArg] | None = ...,
        component_name: _builtins.str = ...,
        url: _builtins.str = ...,
        form_id: _builtins.str = ...,
        tab_index: _builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["_tab_index", b"_tab_index", "tab_index", b"tab_index"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["_tab_index", b"_tab_index", "component_name", b"component_name", "form_id", b"form_id", "id", b"id", "json_args", b"json_args", "special_args", b"special_args", "tab_index", b"tab_index", "url", b"url"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__tab_index: _TypeAlias = _typing.Literal["tab_index"]  # noqa: Y015
    _WhichOneofArgType__tab_index: _TypeAlias = _typing.Literal["_tab_index", b"_tab_index"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType__tab_index) -> _WhichOneofReturnType__tab_index | None: ...

Global___ComponentInstance: _TypeAlias = ComponentInstance  # noqa: Y015

@_typing.final
class SpecialArg(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    KEY_FIELD_NUMBER: _builtins.int
    ARROW_DATAFRAME_FIELD_NUMBER: _builtins.int
    BYTES_FIELD_NUMBER: _builtins.int
    key: _builtins.str
    bytes: _builtins.bytes
    @_builtins.property
    def arrow_dataframe(self) -> Global___ArrowDataframe: ...
    def __init__(
        self,
        *,
        key: _builtins.str = ...,
        arrow_dataframe: Global___ArrowDataframe | None = ...,
        bytes: _builtins.bytes = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["arrow_dataframe", b"arrow_dataframe", "bytes", b"bytes", "value", b"value"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["arrow_dataframe", b"arrow_dataframe", "bytes", b"bytes", "key", b"key", "value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_value: _TypeAlias = _typing.Literal["arrow_dataframe", "bytes"]  # noqa: Y015
    _WhichOneofArgType_value: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_value) -> _WhichOneofReturnType_value | None: ...

Global___SpecialArg: _TypeAlias = SpecialArg  # noqa: Y015

@_typing.final
class ArrowDataframe(_message.Message):
    """Components uses Apache Arrow for dataframe serialization.
    This is distinct from `Arrow.proto`: Components was created before
    Streamlit supported Arrow for internal dataframe serialization, and the
    two implementations currently use different logic + data structures.
    """

    DESCRIPTOR: _descriptor.Descriptor

    DATA_FIELD_NUMBER: _builtins.int
    HEIGHT_FIELD_NUMBER: _builtins.int
    WIDTH_FIELD_NUMBER: _builtins.int
    height: _builtins.int
    width: _builtins.int
    @_builtins.property
    def data(self) -> Global___ArrowTable: ...
    def __init__(
        self,
        *,
        data: Global___ArrowTable | None = ...,
        height: _builtins.int = ...,
        width: _builtins.int = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["data", b"data"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["data", b"data", "height", b"height", "width", b"width"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ArrowDataframe: _TypeAlias = ArrowDataframe  # noqa: Y015

@_typing.final
class ArrowTable(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    DATA_FIELD_NUMBER: _builtins.int
    INDEX_FIELD_NUMBER: _builtins.int
    COLUMNS_FIELD_NUMBER: _builtins.int
    STYLER_FIELD_NUMBER: _builtins.int
    data: _builtins.bytes
    index: _builtins.bytes
    columns: _builtins.bytes
    @_builtins.property
    def styler(self) -> Global___ArrowTableStyler: ...
    def __init__(
        self,
        *,
        data: _builtins.bytes = ...,
        index: _builtins.bytes = ...,
        columns: _builtins.bytes = ...,
        styler: Global___ArrowTableStyler | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["styler", b"styler"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["columns", b"columns", "data", b"data", "index", b"index", "styler", b"styler"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ArrowTable: _TypeAlias = ArrowTable  # noqa: Y015

@_typing.final
class ArrowTableStyler(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    UUID_FIELD_NUMBER: _builtins.int
    CAPTION_FIELD_NUMBER: _builtins.int
    STYLES_FIELD_NUMBER: _builtins.int
    DISPLAY_VALUES_FIELD_NUMBER: _builtins.int
    uuid: _builtins.str
    caption: _builtins.str
    styles: _builtins.str
    display_values: _builtins.bytes
    def __init__(
        self,
        *,
        uuid: _builtins.str = ...,
        caption: _builtins.str = ...,
        styles: _builtins.str = ...,
        display_values: _builtins.bytes = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["caption", b"caption", "display_values", b"display_values", "styles", b"styles", "uuid", b"uuid"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ArrowTableStyler: _TypeAlias = ArrowTableStyler  # noqa: Y015
